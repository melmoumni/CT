#include <iostream>
#include <cstdlib>
#include <string>
#include <sstream>
#include <opencv.hpp>
#include <opencv2/video/background_segm.hpp>

using namespace std;
using namespace cv;

const char* WINDOW_NAME = "Video window";

Mat extract_object(Mat src_gray) {
  Mat canny_output;
  int thresh = 100;
  vector<vector<Point> > contours;
  vector<Vec4i> hierarchy;
  RNG rng(12345);

  // Detect edges using canny
  Canny( src_gray, canny_output, thresh, thresh*2, 3 );
  // Find contours
  findContours( canny_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );

  // Draw contours
  Mat drawing = Mat::zeros( canny_output.size(), CV_8UC3 );
  for( int i = 0; i < (int)contours.size(); i++ ) {
    Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );
    drawContours( drawing, contours, i, color, 2, 8, hierarchy, 0, Point() );
  }
  
  return drawing;
}



void drawOptFlowMap (const Mat& flow, Mat& cflowmap, int step, const Scalar& color) {  
  for(int y = 0; y < cflowmap.rows; y += step)  
    for(int x = 0; x < cflowmap.cols; x += step) {  
      const Point2f& fxy = flow.at< Point2f>(y, x);  
      line(cflowmap, Point(x,y), Point(cvRound(x+fxy.x), cvRound(y+fxy.y)), color);  
      circle(cflowmap, Point(cvRound(x+fxy.x), cvRound(y+fxy.y)), 1, color, -1);  
    }  
}  


void process(const char* videoname){
  VideoCapture cap(videoname); 
  if(!cap.isOpened())
    exit(EXIT_FAILURE);
  
  Mat frame;
  Mat last_frame;
  Mat result;
  Mat acc_frame;
  Mat acc_last_frame;
  bool first = true;
  Mat frame_opened;
  Mat frame_closed;
  Mat contours;

  Mat fgMaskMOG; //fg mask generated by MOG method
  Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
  Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
  pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach


  while(cap.read(frame)) {  
    cvtColor(frame, frame, CV_BGR2GRAY);
		
    if(first) {
      frame.copyTo(last_frame);
      first = false;
    }
    //get diff and threshold - naive movements
    absdiff(last_frame, frame, result);
    threshold(result, result, 127.0, 255, THRESH_BINARY);

    //Use BACKGROUND SUBTRACTION
    Mat frame2;
    frame.copyTo(frame2);
    pMOG2->apply(frame2, fgMaskMOG2);
    //get the frame number and write it on the current frame
    stringstream ss;
    rectangle(frame2, cv::Point(10, 2), cv::Point(100,20), cv::Scalar(255,255,255), -1);
    ss << cap.get(CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(frame2, frameNumberString.c_str(), cv::Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

    //morhology operations
    Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(4, 15));
    morphologyEx(frame, frame_opened, MORPH_OPEN, kernel);
    morphologyEx(frame_opened, frame_closed, MORPH_CLOSE, kernel);

    //detect object
    contours = extract_object(frame_opened);
		line(frame2, Point(325, 80), Point(250, 300), Scalar(255, 255, 255), 2, 8 );
    
    //calcOpticalFlowFarneback
    Mat flow;
    Mat cflow;
    calcOpticalFlowFarneback(last_frame, frame, flow, 0.5, 3, 15, 3, 5, 1.2, 0);      
    cvtColor(last_frame, cflow, CV_GRAY2BGR);
    drawOptFlowMap(flow, cflow, 10, CV_RGB(0,255,0));
  
    imshow("frame", frame2);
    imshow("Result", result);
    imshow("contours", contours);
    imshow("cflow", cflow);
    imshow("FG Mask MOG 2", fgMaskMOG2);
    while(waitKey(30) < 0);
  }
}

void usage(const char *s){
  cerr<<"Usage: "<<s<<" videoName"<<endl;
  exit(EXIT_FAILURE);
}

int main(int argc, char **argv){
  if(argc != 2)
    usage(argv[0]);
  process(argv[1]);

  return EXIT_SUCCESS;
}
